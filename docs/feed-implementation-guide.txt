RAGESTATE FEED IMPLEMENTATION GUIDE
===================================

This guide outlines the steps to create a social feed for RAGESTATE, leveraging 
the existing Firebase infrastructure. The feed will allow users to post content,
like and comment on posts, and view a personalized timeline.

STATUS CHECKLIST
----------------
- [x] Indexes defined and deployed (firestore.indexes.json in repo)
- [x] Security rules hardened and deployed (userFeeds client read-only)
- [x] Cloud Functions v2: counters (likes/comments) transactional
- [x] Fan-out to userFeeds/{uid}/feedItems (personal feeds) live
- [x] Client: personalized feed pagination + public fallback
- [x] Client: /feed/latest route (global latest)
- [x] Client: like toggle (optimistic)
- [x] Client: comments UI + pagination
- [x] Post composer (text + single image)
- [ ] Follow graph UI (FollowButton)
- [ ] UX polish + tests/metrics
- [ ] Privacy toggle (Public/Private) end-to-end
- [ ] Post edit (author-only) with audit fields
- [ ] Post delete (author-only) with cleanup
- [ ] Functions onUpdate/onDelete for posts visibility & cleanup

1. FIRESTORE DATABASE STRUCTURE
-------------------------------

Create the following collections in Firestore:

- posts
  - postId (document)
    - userId: string (author ID)
    - userDisplayName: string
    - userProfilePicture: string
    - content: string (post text)
    - mediaUrls: array (optional images/videos)
    - mediaType: string ('image', 'video', null)
    - timestamp: timestamp
      - updatedAt: timestamp (null unless edited)
      - edited: boolean (default false)
    - likeCount: number
    - commentCount: number
    - tags: array (optional)
      - isPublic: boolean (true=public, false=private to author only)
    
- postLikes
  - likeId (document)
    - postId: string (reference to post)
    - userId: string (user who liked)
    - timestamp: timestamp
    
- postComments
  - commentId (document)
    - postId: string (reference to post)
    - userId: string (commenter ID)
    - userDisplayName: string
    - userProfilePicture: string
    - content: string
    - timestamp: timestamp
    - likeCount: number (optional for comment likes)

- userFeeds
  - userId (document)
    - postIds: array (references to posts to show in feed)
    - lastUpdated: timestamp

2. FIREBASE SECURITY RULES
--------------------------

Add these rules to protect your feed data:

```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Posts - users can read public posts, create their own, edit own
      match /posts/{postId} {
         allow read: if resource.data.isPublic == true || resource.data.userId == request.auth.uid;
         allow create: if request.auth != null &&
            request.resource.data.userId == request.auth.uid &&
            request.resource.data.timestamp is timestamp &&
            request.resource.data.likeCount == 0 &&
            request.resource.data.commentCount == 0 &&
            request.resource.data.isPublic is bool &&
            (request.resource.data.content is string &&
               request.resource.data.content.size() <= 2000);

         // Author-only updates with field protections
         allow update: if request.auth != null && resource.data.userId == request.auth.uid &&
            // Immutable critical fields
            request.resource.data.userId == resource.data.userId &&
            request.resource.data.timestamp == resource.data.timestamp &&
            // Client cannot modify counters
            request.resource.data.likeCount == resource.data.likeCount &&
            request.resource.data.commentCount == resource.data.commentCount &&
            // Edited flag and updatedAt may be set when content/media/visibility change
            (request.resource.data.edited is bool) &&
            (request.resource.data.updatedAt is timestamp || request.resource.data.updatedAt == null) &&
            // Validate content length and media types
            (request.resource.data.content is string && request.resource.data.content.size() <= 2000) &&
            (request.resource.data.mediaUrls is list || request.resource.data.mediaUrls == resource.data.mediaUrls) &&
            (request.resource.data.isPublic is bool);

         // Author-only delete
         allow delete: if request.auth != null && resource.data.userId == request.auth.uid;
      }
    
    // Likes - users can read, create their own, delete own
    match /postLikes/{likeId} {
      allow read;
      allow create: if request.auth != null;
      allow delete: if resource.data.userId == request.auth.uid;
    }
    
    // Comments - users can read public post comments, create their own, edit/delete own
    match /postComments/{commentId} {
      allow read;
      allow create: if request.auth != null;
      allow update, delete: if resource.data.userId == request.auth.uid;
    }
    
    // User feeds - users can only access their own feed
    match /userFeeds/{userId} {
      allow read, write: if userId == request.auth.uid;
    }
  }
}
```

3. CREATE REACT COMPONENTS
--------------------------

The feed UI will require several components:

A. components/feed/FeedContainer.js
   - Main container for the feed
   - Handles post loading and pagination

B. components/feed/CreatePostForm.js
   - Form for creating new posts
   - Media upload functionality

C. components/feed/PostCard.js
   - Individual post display
   - Like and comment interactions
   - Media preview

D. components/feed/CommentSection.js
   - Comment display and creation
   - Nested comments if desired

E. components/feed/FeedFilter.js
   - Options to filter feed content (latest, trending, etc.)

4. IMPLEMENT FIREBASE FUNCTIONS
------------------------------

Create the following Firebase functions to support the feed:

A. processNewPost
   - Triggered when new post is created
   - Update follower feeds
   - Process media (generate thumbnails, etc.)
   - Extract hashtags and mentions

B. updateFeedCounts
   - Triggered when posts are liked/commented
   - Updates counters atomically
D. onUpdatePost (posts/{postId})
    - Detect changes to `isPublic`:
       - If changed from true → false: remove this post from followers' `userFeeds/{uid}/feedItems` and from any public caches/indexes.
       - If changed from false → true: fan-out to followers (same as onCreate path) and eligible public lists.
    - If `content` or `mediaUrls` change: no fan-out needed; just ensure `edited=true` and `updatedAt=now` are set. Do not touch counters.
    - Guardrails: ignore updates where only counters changed (should be handled by separate counter functions).

E. onDeletePost (posts/{postId})
    - Remove associated docs:
       - Delete `userFeeds/{followerId}/feedItems/{postId}` for all followers and the author.
       - Delete `postLikes` (batched/paginated) for this post.
       - Delete `postComments` (batched/paginated) for this post.
       - Delete Storage media under `posts/{postId}/...` (if any).
    - Consider a soft-delete flag in future; for now, hard delete.

C. notifyMentionedUsers
   - Send notifications when users are mentioned
   - Add post to their feed

D. scheduledFeedRefresh
   - Periodically update user feeds with relevant content
   - Remove old/stale content

5. IMPLEMENT CORE FUNCTIONALITY
------------------------------

A. Post Creation
   - Add text entry form
   - Media upload and preview
   - Post submission to Firebase

B. Feed Display
   - Realtime feed updates using Firebase onSnapshot
   - Infinite scroll pagination
   - Pull-to-refresh

C. Post Interactions
   - Like/unlike posts
   - Comment on posts
   - Share posts

D. User-specific Feeds
   - Show posts from followed users
   - Include suggested content

E. Privacy (Public/Private)
   - Add a visibility toggle to the composer and edit flow: `Public` (default) or `Private`.
   - Private posts are visible only to the author; do not appear in followers' feeds or public latest.
   - UI: badge on the post card indicating `Private` for the author.

F. Edit Post
   - Author can edit `content`, `mediaUrls`, and `isPublic`.
   - On save: set `edited=true` and `updatedAt=serverTimestamp()`.
   - If `isPublic` changes, backend function handles fan-out removal/addition.
   - Client should optimistically update UI and disable save while pending.

G. Delete Post
   - Author can delete their post from overflow menu on the post card.
   - Confirmation dialog required.
   - On success, remove from UI immediately; backend cleanup will proceed via function.

6. OPTIMIZATION TECHNIQUES
-------------------------

A. Pagination
   - Use Firestore's limit() and startAfter() for efficient loading
   - Initially load 10-15 posts, then load more as needed

B. Caching
   - Cache feed data locally
   - Use service worker for offline access

C. Lazy Loading
   - Lazy load images and videos
   - Defer loading comments until expanded

D. Denormalization
   - Store duplicate data (like usernames) to avoid excess queries
   - Keep counters (likes, comments) on posts to avoid counting on-the-fly
   - Store `edited` and `updatedAt` on the post to avoid additional lookups

7. IMPLEMENTATION ORDER
----------------------

Phase 1: Basic Feed
   - Setup Firestore collections and security rules
   - Create post creation form
   - Implement basic feed display
   - Add like functionality

Phase 2: Enhanced Interactions
   - Add comment functionality
   - Implement media uploads
   - Create user profile integration
   - Add basic notifications

Phase 2.5: Privacy + Edit/Delete
   - Add Public/Private toggle to composer and post card edit.
   - Implement client edit modal and delete flow.
   - Deploy updated security rules validating immutable and protected fields.
   - Add `onUpdatePost` and `onDeletePost` functions and verify feed fan-out changes.

Phase 3: Advanced Features
   - Add hashtags and trending topics
   - Implement post sharing
   - Create personalized feed algorithm
   - Add feed filters and search

8. TESTING STRATEGY
------------------

A. Component Testing
   - Test individual feed components with mock data
   - Verify like/comment functionality works

B. Integration Testing
   - Test feed with real Firebase backend
   - Verify realtime updates work properly
   - Verify visibility changes: public→private removes from follower feeds; private→public adds.
   - Verify edit/update respects rules (counters immutable from client).

C. Performance Testing
   - Test with large datasets
   - Verify scroll performance remains smooth
   - Measure and optimize load times

9. ADDITIONAL CONSIDERATIONS
---------------------------

A. Privacy Settings
   - Allow users to create public/private posts (toggle in composer and edit)
   - Control who can comment on posts
   - Future: add `followers-only` as a third visibility state (requires fan-out to followers only)

B. Content Moderation
   - Implement reporting system
   - Create admin tools for content review

C. Analytics
   - Track post engagement
   - Measure user retention via feed

D. A/B Testing
   - Test different feed layouts and ranking algorithms
   - Optimize for engagement

10. MAINTENANCE PLAN
-------------------

A. Regular Security Reviews
   - Check Firestore rules regularly
   - Update permissions as needed

B. Performance Monitoring
   - Monitor Firebase quotas and usage
   - Optimize queries that become slow

C. Content Growth Strategy
   - Plan for database scaling
   - Consider sharding strategies for large post volumes

Remember to leverage your existing user authentication and profile system 
to integrate seamlessly with the new feed functionality.

11. SOCIAL GRAPH & FEED STRATEGY
--------------------------------

A. Follow graph
   - Collection: `follows`
     - docId: `${followerId}_${followedId}` (or auto-id with both fields indexed)
     - followerId: string
     - followedId: string
     - createdAt: timestamp

   Indexes:
   - followerId ASC (list who I follow)
   - followedId ASC (list who follows a user)

B. Feed generation options
   - On-read (recommended for MVP): Query `posts` by authors the user follows via batched `where('__name__','in',..)` is not viable at scale; instead:
     - Maintain `userFeeds/{userId}` with a rolling window of latest ~500 postIds via Cloud Functions fan-out on write (bounded list + TTL trim).
     - Read: page through `userFeeds/{userId}.postIds` in chunks and hydrate posts by `where(documentId(), 'in', batchOf10)`.
   - Hybrid: Also support a public "Latest" tab that queries recent public posts regardless of follow.
   - Ranking (Phase 2): Store engagement features (likeCount delta, recency bucket, author affinity) and rank client-side or via a small Cloud Function endpoint.

C. Media handling
   - Upload to Firebase Storage under `posts/{postId}/{filename}`.
   - Generate resized images/thumbnails via a Storage-triggered CF; store under `posts/{postId}/thumb_...` and update `mediaVariants` on the post.
   - Prefer MP4/WebM for video; store poster image.

12. UI ROUTES AND COMPONENTS (NEXT.JS APP ROUTER)
-------------------------------------------------

Routes
 - `/feed` (personalized) and `/feed/latest` (global latest)
 - `/post/[postId]` (permalink, SEO)
 - `/profile/[userId]` (user timeline + follow/DM)

Components
 - `src/app/feed/page.js` (server shell + client hydrated list)
 - `components/feed/FeedContainer.js` (client; pagination/infinite scroll)
 - `components/feed/PostComposer.js` (create post with media upload)
 - `components/feed/PostCard.js` (display, like, comment count)
 - `components/feed/CommentsSheet.js` (lazy drawer/modal to fetch comments on demand)
 - `components/feed/FollowButton.js`
   - `components/feed/EditPostModal.js` (edit content/visibility)

Performance
 - Lazy-load `CommentsSheet` and any heavy media players.
 - Use `next/image` with `sizes` and responsive layout.
 - Subscribe to live updates only for the visible window of posts, or rely on background refresh + pull-to-refresh to control read costs.

13. CLOUD FUNCTIONS (DETAIL)
----------------------------

A. onCreate(post)
   - Read the author’s followers (bounded by pagination; fan-out in batches).
   - Append `postId` to each `userFeeds/{followerId}.postIds` array or a `feedItems` subcollection with `createdAt` for easy pagination.
   - Trim feed documents to a max length (e.g., 500) to bound read/compute.

B. onWrite(like/comment)
   - Transactionally update `likeCount`/`commentCount` on post.
   - Optionally write a `engagements/{postId}` aggregate doc for ranking.

C. scheduled (every 15m)
   - Trim stale items from `userFeeds`.
   - Recompute lightweight trending metrics (e.g., likes in last 2h).

D. storage.onFinalize
   - If image/video uploaded, generate thumbnails/poster and update post.

14. SECURITY RULES (HARDENED)
-----------------------------

Rules additions beyond Section 2:
```
match /follows/{id} {
  allow read: if true; // profiles are public; tighten if needed
  allow create: if request.auth != null &&
    request.resource.data.followerId == request.auth.uid &&
    request.resource.data.followedId is string &&
    request.resource.data.followerId != request.resource.data.followedId;
  allow delete: if request.auth != null && resource.data.followerId == request.auth.uid;
}

match /userFeeds/{userId} {
  allow read: if request.auth != null && request.auth.uid == userId;
  allow write: if false; // Only CF service account writes
}

// Extra validations on posts to prevent client tampering of counters and identity
match /posts/{postId} {
   allow update: if request.auth != null && resource.data.userId == request.auth.uid &&
      request.resource.data.likeCount == resource.data.likeCount &&
      request.resource.data.commentCount == resource.data.commentCount &&
      request.resource.data.userId == resource.data.userId;
}
```

Consider separate `feedItems` subcollection to avoid large arrays:
 - `userFeeds/{userId}/feedItems/{postId}` with fields: createdAt, rank.
 - Paginate with `orderBy('createdAt','desc')` + `limit()` + `startAfter()`.

15. INDEXES
-----------

- posts: `timestamp DESC`, `userId ASC, timestamp DESC` (author timeline)
- postComments: `postId ASC, timestamp ASC`
- follows: `followerId ASC`, `followedId ASC`
- userFeeds.feedItems: `createdAt DESC`

16. ROLLOUT PLAN (MVP → V2)
---------------------------

MVP (2–3 sprints)
 - Post text + images, public posts
 - Personal feed via fan-out to `userFeeds/feedItems` (bounded)
 - Likes, basic comments (loaded on demand)
 - Profiles with follow/unfollow
 - Content reporting flag (write to `reports` collection)
   - Public/Private toggle
   - Edit/Delete by author

V2
 - Video upload with server-side poster/thumbs
 - Notifications (Cloud Messaging) on likes/comments/follows
 - Hashtags + simple search
 - Basic ranking (recency + small engagement boost)
 - Moderation tooling (admin UI list of reports; takedown)
   - Followers-only visibility (requires follow-aware fan-out)

V3
 - Stories/shorts (separate collection + TTL)
 - Advanced ranking and A/B testing
 - Saved posts/collections

17. METRICS & ALERTING
----------------------

- Track: DAU of feed, posts/day, median time-to-first-post, scroll depth, submit-to-visible latency.
- Errors: upload failures, function latency, rules denials.
- Cost: reads per session; cap listeners and rely on paginated queries.

18. NEXT STEPS (SEQUENTIAL CHECKLIST)
-------------------------------------

Preflight (once)
- [ ] Ensure Firebase web env vars are set (no quotes) locally and on hosting:
   - NEXT_PUBLIC_FIREBASE_API_KEY
   - NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN
   - NEXT_PUBLIC_FIREBASE_PROJECT_ID
   - NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET
   - NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID
   - NEXT_PUBLIC_FIREBASE_APP_ID
- [ ] Confirm Firestore and Storage are enabled in the Firebase console.

Step 1 — Indexes (see Section 15)
- [x] posts: isPublic ASC, timestamp DESC
- [x] posts: userId ASC, timestamp DESC
- [x] postComments: postId ASC, timestamp ASC
- [x] follows: followerId ASC; followedId ASC
- [x] userFeeds.feedItems: createdAt DESC (single-field; automatic)

Step 2 — Harden Security Rules (see Section 14)
- [x] Lock userFeeds writes to Functions only; keep reads to owner.
- [x] Validate post creates (userId == auth.uid, isPublic boolean, content length cap).
- [x] Constrain follows create/delete to the acting user; prevent self-follow.
Deploy rules.

Step 2.5 — Privacy + Edit/Delete
- [ ] Add `edited` (bool) and `updatedAt` (timestamp|null) fields to posts; default edited=false.
- [ ] Update composer to include Public/Private toggle; default Public.
- [ ] Add EditPostModal from PostCard overflow for author; supports content and visibility.
- [ ] Add Delete action with confirm.
- [ ] Deploy updated rules preventing counter/userId tampering.
- [ ] Add/Deploy `onUpdatePost` and `onDeletePost` functions and validate fan-out changes and cleanup.

Step 3 — Cloud Functions: Counters
- [x] Implement onCreate/onDelete for postLikes to inc/dec posts.likeCount atomically.
- [x] Implement onCreate/onDelete for postComments to inc/dec posts.commentCount.
Deploy and verify with a quick like/comment.

Step 4 — Cloud Functions: Fan-out (personal feeds)
- [x] Implement onCreate(posts/{postId}) to fan-out to followers.
   - [x] Write userFeeds/{followerId}/feedItems/{postId} = { createdAt: now }.
   - [x] Trim to max N (e.g., 500) items per user.
Deploy and test with a new post.

Step 5 — Data Model Tweak (avoid large arrays)
- [x] Migrate from userFeeds.postIds array → userFeeds/{userId}/feedItems subcollection.
- [ ] Backfill dev data (optional) by copying existing postIds into feedItems.

Step 6 — Client: Personalized feed pagination
- [x] Page feedItems by createdAt desc; hydrate posts by documentId() in ≤10-id chunks with startAfter cursor.
- [x] Keep a fallback to public Latest if no personalized items.

 Step 7 — Client: Global Latest route
 - [x] Add /feed/latest that queries posts where isPublic == true orderBy timestamp desc with pagination.
 Note: Required posts composite indexes are already in place.

Step 8 — Likes (optimistic)
- [x] Toggle like by writing postLikes doc id `${postId}_${uid}`; disable button while in-flight.
- [x] Optimistically adjust local likeCount; let Functions settle truth.
- [x] Handle signed-out state with prompt/redirect to login.
Note: Likes are enabled only for authenticated users by security rules; guests can view counts but cannot like/unlike.

Step 9 — Comments (lazy sheet)
- [x] Create CommentsSheet; open on demand from the post card.
- [x] Query postComments where postId == target, order by timestamp asc, paginate.
- [x] Post a new comment; rely on Functions to bump count.
Note: Comments require authentication to create; guests can read.

 Step 10 — Post Composer (text → single image)
 - [x] Build composer with text validation and optional single image upload to Storage `posts/{postId}/...`.
 - [x] On submit: create post with isPublic: true, timestamp: server time, mediaUrls if present.
 - [x] Autosave draft to sessionStorage; basic error and loading states.

Step 11 — Follow graph UI
 - [x] Add FollowButton that creates/deletes `follows` doc id `${followerId}_${followedId}` optimistically.
 - [x] Use a single read to reflect initial state.

Step 12 — UX polish and quality gates
- [x] Add "New Posts" banner when newer items appear above viewport; tap scrolls/merges.
- [x] Empty, error, and offline states per spec; respect prefers-reduced-motion.
- [x] Add minimal metrics hooks (post_create, reaction_add, comments_open, post_share).
- [x] Component tests for Post and PostActions interactions; pagination tests deferred.

Done when
- Personalized feed paginates from feedItems for signed-in users; /feed/latest works.
- Users can create a text post (and with a single image), like/unlike, and comment.
- Counts update accurately via Cloud Functions; rules enforce client cannot write userFeeds.
- Basic UX polish and metrics are in place.
