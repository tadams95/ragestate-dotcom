RAGESTATE FEED IMPLEMENTATION GUIDE
===================================

This guide outlines the steps to create a social feed for RAGESTATE, leveraging 
the existing Firebase infrastructure. The feed will allow users to post content,
like and comment on posts, and view a personalized timeline.

1. FIRESTORE DATABASE STRUCTURE
-------------------------------

Create the following collections in Firestore:

- posts
  - postId (document)
    - userId: string (author ID)
    - userDisplayName: string
    - userProfilePicture: string
    - content: string (post text)
    - mediaUrls: array (optional images/videos)
    - mediaType: string ('image', 'video', null)
    - timestamp: timestamp
    - likeCount: number
    - commentCount: number
    - tags: array (optional)
    - isPublic: boolean
    
- postLikes
  - likeId (document)
    - postId: string (reference to post)
    - userId: string (user who liked)
    - timestamp: timestamp
    
- postComments
  - commentId (document)
    - postId: string (reference to post)
    - userId: string (commenter ID)
    - userDisplayName: string
    - userProfilePicture: string
    - content: string
    - timestamp: timestamp
    - likeCount: number (optional for comment likes)

- userFeeds
  - userId (document)
    - postIds: array (references to posts to show in feed)
    - lastUpdated: timestamp

2. FIREBASE SECURITY RULES
--------------------------

Add these rules to protect your feed data:

```
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {
    // Posts - users can read public posts, create their own, edit own
    match /posts/{postId} {
      allow read: if resource.data.isPublic == true || resource.data.userId == request.auth.uid;
      allow create: if request.auth != null && request.resource.data.userId == request.auth.uid;
      allow update, delete: if resource.data.userId == request.auth.uid;
    }
    
    // Likes - users can read, create their own, delete own
    match /postLikes/{likeId} {
      allow read;
      allow create: if request.auth != null;
      allow delete: if resource.data.userId == request.auth.uid;
    }
    
    // Comments - users can read public post comments, create their own, edit/delete own
    match /postComments/{commentId} {
      allow read;
      allow create: if request.auth != null;
      allow update, delete: if resource.data.userId == request.auth.uid;
    }
    
    // User feeds - users can only access their own feed
    match /userFeeds/{userId} {
      allow read, write: if userId == request.auth.uid;
    }
  }
}
```

3. CREATE REACT COMPONENTS
--------------------------

The feed UI will require several components:

A. components/feed/FeedContainer.js
   - Main container for the feed
   - Handles post loading and pagination

B. components/feed/CreatePostForm.js
   - Form for creating new posts
   - Media upload functionality

C. components/feed/PostCard.js
   - Individual post display
   - Like and comment interactions
   - Media preview

D. components/feed/CommentSection.js
   - Comment display and creation
   - Nested comments if desired

E. components/feed/FeedFilter.js
   - Options to filter feed content (latest, trending, etc.)

4. IMPLEMENT FIREBASE FUNCTIONS
------------------------------

Create the following Firebase functions to support the feed:

A. processNewPost
   - Triggered when new post is created
   - Update follower feeds
   - Process media (generate thumbnails, etc.)
   - Extract hashtags and mentions

B. updateFeedCounts
   - Triggered when posts are liked/commented
   - Updates counters atomically

C. notifyMentionedUsers
   - Send notifications when users are mentioned
   - Add post to their feed

D. scheduledFeedRefresh
   - Periodically update user feeds with relevant content
   - Remove old/stale content

5. IMPLEMENT CORE FUNCTIONALITY
------------------------------

A. Post Creation
   - Add text entry form
   - Media upload and preview
   - Post submission to Firebase

B. Feed Display
   - Realtime feed updates using Firebase onSnapshot
   - Infinite scroll pagination
   - Pull-to-refresh

C. Post Interactions
   - Like/unlike posts
   - Comment on posts
   - Share posts

D. User-specific Feeds
   - Show posts from followed users
   - Include suggested content

6. OPTIMIZATION TECHNIQUES
-------------------------

A. Pagination
   - Use Firestore's limit() and startAfter() for efficient loading
   - Initially load 10-15 posts, then load more as needed

B. Caching
   - Cache feed data locally
   - Use service worker for offline access

C. Lazy Loading
   - Lazy load images and videos
   - Defer loading comments until expanded

D. Denormalization
   - Store duplicate data (like usernames) to avoid excess queries
   - Keep counters (likes, comments) on posts to avoid counting on-the-fly

7. IMPLEMENTATION ORDER
----------------------

Phase 1: Basic Feed
   - Setup Firestore collections and security rules
   - Create post creation form
   - Implement basic feed display
   - Add like functionality

Phase 2: Enhanced Interactions
   - Add comment functionality
   - Implement media uploads
   - Create user profile integration
   - Add basic notifications

Phase 3: Advanced Features
   - Add hashtags and trending topics
   - Implement post sharing
   - Create personalized feed algorithm
   - Add feed filters and search

8. TESTING STRATEGY
------------------

A. Component Testing
   - Test individual feed components with mock data
   - Verify like/comment functionality works

B. Integration Testing
   - Test feed with real Firebase backend
   - Verify realtime updates work properly

C. Performance Testing
   - Test with large datasets
   - Verify scroll performance remains smooth
   - Measure and optimize load times

9. ADDITIONAL CONSIDERATIONS
---------------------------

A. Privacy Settings
   - Allow users to create public/private posts
   - Control who can comment on posts

B. Content Moderation
   - Implement reporting system
   - Create admin tools for content review

C. Analytics
   - Track post engagement
   - Measure user retention via feed

D. A/B Testing
   - Test different feed layouts and ranking algorithms
   - Optimize for engagement

10. MAINTENANCE PLAN
-------------------

A. Regular Security Reviews
   - Check Firestore rules regularly
   - Update permissions as needed

B. Performance Monitoring
   - Monitor Firebase quotas and usage
   - Optimize queries that become slow

C. Content Growth Strategy
   - Plan for database scaling
   - Consider sharding strategies for large post volumes

Remember to leverage your existing user authentication and profile system 
to integrate seamlessly with the new feed functionality.

11. SOCIAL GRAPH & FEED STRATEGY
--------------------------------

A. Follow graph
   - Collection: `follows`
     - docId: `${followerId}_${followedId}` (or auto-id with both fields indexed)
     - followerId: string
     - followedId: string
     - createdAt: timestamp

   Indexes:
   - followerId ASC (list who I follow)
   - followedId ASC (list who follows a user)

B. Feed generation options
   - On-read (recommended for MVP): Query `posts` by authors the user follows via batched `where('__name__','in',..)` is not viable at scale; instead:
     - Maintain `userFeeds/{userId}` with a rolling window of latest ~500 postIds via Cloud Functions fan-out on write (bounded list + TTL trim).
     - Read: page through `userFeeds/{userId}.postIds` in chunks and hydrate posts by `where(documentId(), 'in', batchOf10)`.
   - Hybrid: Also support a public "Latest" tab that queries recent public posts regardless of follow.
   - Ranking (Phase 2): Store engagement features (likeCount delta, recency bucket, author affinity) and rank client-side or via a small Cloud Function endpoint.

C. Media handling
   - Upload to Firebase Storage under `posts/{postId}/{filename}`.
   - Generate resized images/thumbnails via a Storage-triggered CF; store under `posts/{postId}/thumb_...` and update `mediaVariants` on the post.
   - Prefer MP4/WebM for video; store poster image.

12. UI ROUTES AND COMPONENTS (NEXT.JS APP ROUTER)
-------------------------------------------------

Routes
 - `/feed` (personalized) and `/feed/latest` (global latest)
 - `/post/[postId]` (permalink, SEO)
 - `/profile/[userId]` (user timeline + follow/DM)

Components
 - `src/app/feed/page.js` (server shell + client hydrated list)
 - `components/feed/FeedContainer.js` (client; pagination/infinite scroll)
 - `components/feed/PostComposer.js` (create post with media upload)
 - `components/feed/PostCard.js` (display, like, comment count)
 - `components/feed/CommentsSheet.js` (lazy drawer/modal to fetch comments on demand)
 - `components/feed/FollowButton.js`

Performance
 - Lazy-load `CommentsSheet` and any heavy media players.
 - Use `next/image` with `sizes` and responsive layout.
 - Subscribe to live updates only for the visible window of posts, or rely on background refresh + pull-to-refresh to control read costs.

13. CLOUD FUNCTIONS (DETAIL)
----------------------------

A. onCreate(post)
   - Read the author’s followers (bounded by pagination; fan-out in batches).
   - Append `postId` to each `userFeeds/{followerId}.postIds` array or a `feedItems` subcollection with `createdAt` for easy pagination.
   - Trim feed documents to a max length (e.g., 500) to bound read/compute.

B. onWrite(like/comment)
   - Transactionally update `likeCount`/`commentCount` on post.
   - Optionally write a `engagements/{postId}` aggregate doc for ranking.

C. scheduled (every 15m)
   - Trim stale items from `userFeeds`.
   - Recompute lightweight trending metrics (e.g., likes in last 2h).

D. storage.onFinalize
   - If image/video uploaded, generate thumbnails/poster and update post.

14. SECURITY RULES (HARDENED)
-----------------------------

Rules additions beyond Section 2:
```
match /follows/{id} {
  allow read: if true; // profiles are public; tighten if needed
  allow create: if request.auth != null &&
    request.resource.data.followerId == request.auth.uid &&
    request.resource.data.followedId is string &&
    request.resource.data.followerId != request.resource.data.followedId;
  allow delete: if request.auth != null && resource.data.followerId == request.auth.uid;
}

match /userFeeds/{userId} {
  allow read: if request.auth != null && request.auth.uid == userId;
  allow write: if false; // Only CF service account writes
}
```

Consider separate `feedItems` subcollection to avoid large arrays:
 - `userFeeds/{userId}/feedItems/{postId}` with fields: createdAt, rank.
 - Paginate with `orderBy('createdAt','desc')` + `limit()` + `startAfter()`.

15. INDEXES
-----------

- posts: `timestamp DESC`, `userId ASC, timestamp DESC` (author timeline)
- postComments: `postId ASC, timestamp ASC`
- follows: `followerId ASC`, `followedId ASC`
- userFeeds.feedItems: `createdAt DESC`

16. ROLLOUT PLAN (MVP → V2)
---------------------------

MVP (2–3 sprints)
 - Post text + images, public posts
 - Personal feed via fan-out to `userFeeds/feedItems` (bounded)
 - Likes, basic comments (loaded on demand)
 - Profiles with follow/unfollow
 - Content reporting flag (write to `reports` collection)

V2
 - Video upload with server-side poster/thumbs
 - Notifications (Cloud Messaging) on likes/comments/follows
 - Hashtags + simple search
 - Basic ranking (recency + small engagement boost)
 - Moderation tooling (admin UI list of reports; takedown)

V3
 - Stories/shorts (separate collection + TTL)
 - Advanced ranking and A/B testing
 - Saved posts/collections

17. METRICS & ALERTING
----------------------

- Track: DAU of feed, posts/day, median time-to-first-post, scroll depth, submit-to-visible latency.
- Errors: upload failures, function latency, rules denials.
- Cost: reads per session; cap listeners and rely on paginated queries.

18. NEXT STEPS (SEQUENTIAL CHECKLIST)
-------------------------------------

Preflight (once)
- Ensure Firebase web env vars are set (no quotes) locally and on hosting:
  - NEXT_PUBLIC_FIREBASE_API_KEY
  - NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN
  - NEXT_PUBLIC_FIREBASE_PROJECT_ID
  - NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET
  - NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID
  - NEXT_PUBLIC_FIREBASE_APP_ID
- Confirm Firestore and Storage are enabled in the Firebase console.

Step 1 — Indexes (see Section 15)
- Add/confirm:
  - posts: isPublic ASC, timestamp DESC; userId ASC, timestamp DESC
  - postComments: postId ASC, timestamp ASC
  - follows: followerId ASC; followedId ASC
  - userFeeds.feedItems: createdAt DESC (if using feedItems)

Step 2 — Harden Security Rules (see Section 14)
- Lock userFeeds writes to Functions only; keep reads to owner.
- Validate post creates (userId == auth.uid, isPublic boolean, content length cap).
- Constrain follows create/delete to the acting user; prevent self-follow.
Deploy rules.

Step 3 — Cloud Functions: Counters
- Implement onCreate/onDelete for postLikes to inc/dec posts.likeCount atomically.
- Implement onCreate/onDelete for postComments to inc/dec posts.commentCount.
Deploy and verify with a quick like/comment.

Step 4 — Cloud Functions: Fan-out (personal feeds)
- Implement onCreate(posts/{postId}) to fan-out to followers:
  - Write userFeeds/{followerId}/feedItems/{postId} = { createdAt: now }.
  - Trim to max N (e.g., 500) items per user.
Deploy and test with a new post.

Step 5 — Data Model Tweak (avoid large arrays)
- Migrate from userFeeds.postIds array → userFeeds/{userId}/feedItems subcollection.
- Backfill dev data (optional) by copying existing postIds into feedItems.

Step 6 — Client: Personalized feed pagination
- In Feed container, page feedItems by createdAt desc, batch hydrate posts by documentId() in chunks of ≤10, with startAfter cursor.
- Keep a fallback to public Latest if no personalized items.

Step 7 — Client: Global Latest route
- Add /feed/latest that queries posts where isPublic == true orderBy timestamp desc with pagination.
- Requires the posts composite index above.

Step 8 — Likes (optimistic)
- Toggle like by writing postLikes doc id `${postId}_${uid}`; disable button while in-flight.
- Optimistically adjust local likeCount; let Functions settle truth.
- Handle signed-out state with prompt/redirect to login.

Step 9 — Comments (lazy sheet)
- Create CommentsSheet; open on demand from the post card.
- Query postComments where postId == target, order by timestamp asc, paginate.
- Post a new comment; rely on Functions to bump count.

Step 10 — Post Composer (text → single image)
- Build composer with text validation and optional single image upload to Storage `posts/{postId}/...`.
- On submit: create post with isPublic: true, timestamp: server time, mediaUrls if present.
- Autosave draft to sessionStorage; basic error and loading states.

Step 11 — Follow graph UI
- Add FollowButton that creates/deletes `follows` doc id `${followerId}_${followedId}` optimistically.
- Use a single read to reflect initial state.

Step 12 — UX polish and quality gates
- Add "New Posts" banner when newer items appear above viewport; tap scrolls/merges.
- Empty, error, and offline states per spec; respect prefers-reduced-motion.
- Add minimal metrics hooks (post_create, post_view, reaction_add, comments_open).
- Component tests for PostCard and feed pagination; optional emulator test for Functions.

Done when
- Personalized feed paginates from feedItems for signed-in users; /feed/latest works.
- Users can create a text post (and with a single image), like/unlike, and comment.
- Counts update accurately via Cloud Functions; rules enforce client cannot write userFeeds.
- Basic UX polish and metrics are in place.
